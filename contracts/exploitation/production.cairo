%lang starknet

from starkware.cairo.common.cairo_builtins import HashBuiltin
from starkware.starknet.common.syscalls import get_block_timestamp
from starkware.cairo.common.bool import TRUE
from starkware.cairo.common.math import unsigned_div_rem
from starkware.cairo.common.math_cmp import is_le
from contracts.utils.cairo_math_64x61.math64x61 import Math64x61
from contracts.map.world import world, Plot

// To learn more about Eykar resources and extraction see our wiki: (insert link)

func compute_production{range_check_ptr}(
    dt: felt, q: felt, max_q: felt, affine_growth, linear_growth
) -> felt {
    // Compute resources to extract and update plot content
    //
    // Parameters:
    //   dt: Δt, the delay in seconds since last extraction
    //   q: the previously remaining quantity
    //   max_q: the maximum quantity that this plot can hold
    //   affine_growth: to grow quantity in percentages/s, float
    //   linear_growth: to grow quantity in absolute amount/s, float
    // Returns:
    //   new_q: new quantity after Δt time in these conditions
    alloc_locals;
    let powed_lg = Math64x61._pow_int(linear_growth, dt);
    let expected = q * powed_lg + affine_growth * dt;

    local max_q_float = Math64x61.fromFelt(max_q);
    let test = is_le(expected, max_q_float);

    local new_quantity;
    if (test == TRUE) {
        assert new_quantity = max_q_float;
    } else {
        assert new_quantity = expected;
    }

    return Math64x61.toFelt(new_quantity);
}

func compute_exploitation{range_check_ptr}(
    new_q: felt, extraction_speed, affine_extraction, linear_extraction
) -> felt {
    // Compute resources to extract and update plot content
    //
    // Parameters:
    //   new_q: quantity contained in the plot
    //   extraction_speed: the speed of extraction (usually, the amount of humans), float
    //   affine_extraction: the absolute quantity extracted per speed, float
    //   linear_extraction: the quantity extracted in percentage of quantity, float
    // Returns:
    //   extracted: extracted amound
    alloc_locals;
    let lineared = linear_extraction * new_q;
    local speeded = Math64x61.mul(extraction_speed, lineared + affine_extraction);
    let test = is_le(speeded, new_q * Math64x61.FRACT_PART);

    if (test == TRUE) {
        return Math64x61.toFelt(speeded);
    } else {
        return speeded;
    }
}

func extract{syscall_ptr: felt*, range_check_ptr, pedersen_ptr: HashBuiltin*}(
    x,
    y,
    max_q: felt,
    affine_growth,
    linear_growth,
    extraction_speed,
    affine_extraction,
    linear_extraction,
) -> (extracted: felt) {
    alloc_locals;
    let (timestamp) = get_block_timestamp();
    let (local plot: Plot) = world.read(x, y);
    let dt = timestamp - plot.availability;

    let produced = compute_production(dt, plot.stored, max_q, affine_growth, linear_growth);
    let extracted = compute_exploitation(
        produced, extraction_speed, affine_extraction, linear_extraction
    );

    world.write(x, y, Plot(plot.owner, plot.structure, plot.availability, produced - extracted));
    return (extracted,);
}
