%lang starknet

from starkware.cairo.common.cairo_builtins import HashBuiltin
from starkware.starknet.common.syscalls import get_block_timestamp
from starkware.cairo.common.bool import TRUE
from starkware.cairo.common.math import unsigned_div_rem
from starkware.cairo.common.math_cmp import is_le
from contracts.utils.cairo_math_64x61.math64x61 import Math64x61
from contracts.map.world import world, Plot

# To learn more about Eykar resources and extraction see our wiki: (insert link)

func compute_production{range_check_ptr}(
    dt : felt, q : felt, max_q : felt, affine_growth, linear_growth
) -> (extracted : felt):
    # Compute resources to extract and update plot content
    #
    # Parameters:
    #   dt: Δt, the delay in seconds since last extraction
    #   q: the previously remaining quantity
    #   max_q: the maximum quantity that this plot can hold
    #   affine_growth: to grow quantity in percentages/s, float
    #   linear_growth: to grow quantity in absolute amount/s, float
    # Returns:
    #   new_q: new quantity after Δt time in these conditions
    alloc_locals
    let (powed_lg) = Math64x61._pow_int(linear_growth, dt)
    let expected = q * powed_lg + affine_growth * dt

    let (local max_q_float) = Math64x61.fromFelt(q)
    let (test) = is_le(expected, max_q_float)

    local new_quantity
    if test == TRUE:
        assert new_quantity = max_q_float
    else:
        assert new_quantity = expected
    end

    let (amount) = Math64x61.toFelt(new_quantity)
    return (amount)
end

func compute_exploitation{range_check_ptr}(
    new_q : felt, extraction_speed, affine_extraction, linear_extraction
) -> (extracted : felt):
    # Compute resources to extract and update plot content
    #
    # Parameters:
    #   new_q: quantity contained in the plot
    #   extraction_speed: the speed of extraction (usually, the amount of humans), float
    #   affine_extraction: the absolute quantity extracted per speed, float
    #   linear_extraction: the quantity extracted in percentage of quantity, float
    # Returns:
    #   extracted: extracted amound
    alloc_locals
    let lineared = linear_extraction * new_q
    let (local speeded) = Math64x61.mul(extraction_speed, lineared + affine_extraction)
    let (test) = is_le(speeded, new_q * Math64x61.FRACT_PART)

    if test == TRUE:
        let (extracted) = Math64x61.toFelt(speeded)
        return (extracted)
    else:
        return (speeded)
    end
end

func extract{syscall_ptr : felt*, range_check_ptr, pedersen_ptr : HashBuiltin*}(
    x,
    y,
    max_q : felt,
    affine_growth,
    linear_growth,
    extraction_speed,
    affine_extraction,
    linear_extraction,
) -> (extracted : felt):
    alloc_locals
    let (timestamp) = get_block_timestamp()
    let (local plot : Plot) = world.read(x, y)
    let dt = timestamp - plot.availability

    let (produced) = compute_production(dt, plot.stored, max_q, affine_growth, linear_growth)
    let (extracted) = compute_exploitation(
        produced, extraction_speed, affine_extraction, linear_extraction
    )

    world.write(x, y, Plot(plot.owner, plot.structure, plot.availability, produced - extracted))
    return (extracted)
end
