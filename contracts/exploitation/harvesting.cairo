%lang starknet

from starkware.cairo.common.cairo_builtins import HashBuiltin
from starkware.cairo.common.bool import TRUE, FALSE
from starkware.starknet.common.syscalls import get_block_timestamp
from starkware.cairo.common.math_cmp import is_le

from contracts.convoys.library import has_convoy, assert_can_spend_convoy
from contracts.map.world import Plot, world, Structure
from contracts.map.biomes import lumbercamp_modifier
from contracts.exploitation.production import extract
from contracts.convoys.conveyables.fungibles.wood import Wood, wood_balances
from contracts.convoys.conveyables.fungibles.human import Human, human_balances
from contracts.convoys.conveyables.fungibles.soldier import Soldier, soldier_balances
from contracts.convoys.conveyables.fungibles import Fungibles
from contracts.utils.math import max
from contracts.utils.cairo_math_64x61.math64x61 import Math64x61

func _harvest{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(
    caller, convoy_id, x, y
) {
    alloc_locals;
    // assert convoy is at correct location
    let (test) = has_convoy(convoy_id, x, y);
    assert test = TRUE;

    // assert convoy can be spent by caller
    assert_can_spend_convoy(convoy_id, caller);
    let (plot: Plot) = world.read(x, y);

    if (plot.structure == Structure.SETTLER_CAMP) {
        // harvest non-renewable human
        let (previous_amount) = Fungibles.amount(human_balances.addr, convoy_id);
        let (timestamp) = get_block_timestamp();
        let available_harvest = is_le(plot.availability, timestamp);
        if (available_harvest == TRUE) {
            Fungibles.set(human_balances.addr, convoy_id, previous_amount + 500);
            world.write(x, y, Plot(plot.owner, plot.structure, plot.availability + 7*24*3600, plot.stored));
            return ();
        }
        return ();
    }

    const level = 1;

    if (plot.structure == Structure.TOWN) {
        // harvest renewable humaun
        let affine_growth = Math64x61.div(level * 5 * Math64x61.FRACT_PART, 180 * Math64x61.FRACT_PART);
        let (harvest_amount) = extract(
            x, y, 3000 * level, affine_growth, Math64x61.FRACT_PART, Math64x61.FRACT_PART, 0, Math64x61.FRACT_PART
        );
        let (previous_amount) = Fungibles.amount(human_balances.addr, convoy_id);
        Fungibles.set(human_balances.addr, convoy_id, previous_amount + harvest_amount);
        return ();
    }

    if (plot.structure == Structure.LUMBER_CAMP) {
        // harvest renewable wood
        let (human_balance) = Fungibles.amount(human_balances.addr, convoy_id);
        let (modifier) = lumbercamp_modifier(x, y);
        let affine_growth = Math64x61.div(level * modifier * Math64x61.FRACT_PART, 180 * Math64x61.FRACT_PART);
        let (harvest_amount) = extract(
            x, y, 1200 * level, affine_growth, Math64x61.FRACT_PART, human_balance * Math64x61.FRACT_PART, 20 * Math64x61.FRACT_PART, 0
        );
        let (previous_amount) = Fungibles.amount(wood_balances.addr, convoy_id);
        Fungibles.set(wood_balances.addr, convoy_id, previous_amount + harvest_amount);
        return ();
    }

    if (plot.structure == Structure.BARRACKS) {
        let affine_growth = Math64x61.div(level * 15 * Math64x61.FRACT_PART, 180 * Math64x61.FRACT_PART);
        let (harvest_amount) = extract(
            x, y, 4500 * level, affine_growth, Math64x61.FRACT_PART, Math64x61.FRACT_PART, 0, Math64x61.FRACT_PART
        );
        let (previous_amount) = Fungibles.amount(soldier_balances.addr, convoy_id);
        Fungibles.set(soldier_balances.addr, convoy_id, previous_amount + harvest_amount);
        return ();
    }
    return ();
}
